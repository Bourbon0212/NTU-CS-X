---
title: "Data Visualization with ggplot2 (Part 3)"
author: "Bourbon0212"
date: "2018年7月31日"
output: html_document
---

* [Data Visualization with ggplot2 (Part 2)](https://bourbon0212.github.io/NTU-CS-X/Week3/Data_Visualization_with_ggplot2__Part_2_.html)    
* [Statistical Plots](#1)   
    + [Refresher](#1.1)   
    + [Box Plots](#1.2)   
        + [5-number Summary](#1.2.1)    
        + [Convert Continuous Variables into Ordinal](#1.2.2)   
        + [Box plots with Varying Width](#1.2.3)
    + [Density Plots](#1.3)   
        + [Kernal Density Estimation(KDE)](#1.3.1)    
        + [Mulitple Density Plots](#1.3.2)    
        + [Violin Plots](#1.3.3)    
        + [Weighted Density Plots](#1.3.4)    
    + [2D Density Plots](#1.4)    
        + [2D Density Plots with `viridis`](#1.4.1)     
* [Plots for Specific Data Types](#2)   

<h2 id = '1'></h2>
# **Statistical Plots**   

<h3 id = '1.1'></h3>
## Refresher

#### **Example1: `ggplotmovies`**   

    'movies_small' is a random sample of 1000 observations from the larger movies dataset, that's inside the ggplot2movies package. 
    The dataset contains information on movies from IMDB.
    The variable votes is the number of IMDB users who have rated a movie and the rating is the average rating for the movie.
```{r, message = F}
library(ggplot2movies)
library(ggplot2)
# Sample 1000 movies from ggplot2movies
set.seed(123)
movies_small <- movies[sample(nrow(movies), 1000), ]
movies_small$rating <- factor(round(movies_small$rating))

# Build a scatter plot with mean and 95% CI
ggplot(movies_small, aes(x = rating, y = votes)) +
  geom_point() +
  stat_summary(fun.data = "mean_cl_normal",
               geom = 'crossbar',
               width = 0.2,
               col = 'red') +
  scale_y_log10()
```

#### **Example2: `diamonds`**
```{r}
ggplot(diamonds, aes(x = carat, y = price, col = color)) +
  geom_point(alpha = 0.5, size = 0.5, shape = 16) +
  # To get nice formatting we're using the expression() function for the labels.
  scale_x_log10(expression(log[10](Carat)), limits = c(0.1,10)) +
  scale_y_log10(expression(log[10](Price)), limits = c(100,100000)) +
  scale_color_brewer(palette = "YlOrRd") +
  coord_equal() +
  theme_classic()
```

<h3 id = '1.2'></h3>
## Box Plots

<h4 id = '1.2.1'></h4>
#### **5-number Summary**
<div style="width:600px; height:400px">    
![](D:\Desktop\1.png)
</div>

* Each part of the inner box reflects 25 percent of the data.   
* Outlier: `1.5 * IQR` below `Q1` or above `Q3`.    

#### **Example: `ggplotmovies`** 
```{r}
# Sample 10000 movies from ggplot2movies
set.seed(123)
movies_small <- movies[sample(nrow(movies), 10000), ]
movies_small$rating <- factor(round(movies_small$rating))

# Add a boxplot geom
d <- ggplot(movies_small, aes(x = rating, y = votes)) +
  geom_point() +
  geom_boxplot() +
  stat_summary(fun.data = "mean_cl_normal",
               geom = "crossbar",
               width = 0.2,
               col = "red")

# Untransformed plot
d

# Transform the scale
d + scale_y_log10()

# Transform the coordinates
d + coord_trans(y = "log10")
```

* Notice the difference between the normal distribution estimation (red boxes) and boxplots (less prone to outliers) are.     
* We use `scale_y_log10()` & `coord_trans(y = 'log10')` for transforming the scale.   
    + `scale_` functiion makes transformation before calculating the statistics.    
    + `coord_` function makes transformation after calculating the statistics.    
    + Reference: [**Zooming in with `scale_` & `coord_`**](https://bourbon0212.github.io/NTU-CS-X/Week3/Data_Visualization_with_ggplot2__Part_2_.html#2.1)     
    
<br>

<h4 id = '1.2.2'></h4>
#### **Convert Continuous Variables into Ordinal**

*  Going from a continuous to a categorical variable reduces the amount of information, but sometimes that helps us understand the data. 
* `cut_interval(x, n)` makes `n` groups from vector `x` with equal range.     
* `cut_number(x, n)` makes `n` groups from vector `x` with (approximately) equal numbers of observations.     
* `cut_width(x, width)` makes groups of `width` from vector `x`.      

<br>

#### **Example: `diamonds`**
```{r}
p <- ggplot(diamonds, aes(x = carat, y = price))
# Use cut_interval
p + geom_boxplot(aes(group = cut_interval(carat, n = 10)))

# Use cut_number
p + geom_boxplot(aes(group = cut_number(carat, n = 10)))

# Use cut_width
p + geom_boxplot(aes(group = cut_width(carat, width = 0.25)))
```

<br>

<h4 id = '1.2.3'></h4>
#### **Box plots with Varying Width**
* A drawback of showing a box plot per group, is that you don't have any indication of the sample size.      
* One way of dealing with this is to use a variable width for the box, which reflects differences in `n`.     
* However, there is no legend. It's not a final solution.   

```{r}
ggplot(diamonds, aes(x = cut, y = price, col = color)) +
    geom_boxplot(varwidth = T) +
    facet_grid(.~color)
```

<br>

<h3 id = '1.3'></h3>
## Density Plots

* Distribution of univariate data.    
* Statistics    
    + Probability Density Function
    + Theoretical: Based on formula.
    + Empirical: Based on data.   

<h4 id = '1.3.1'></h4>    
#### **Kernel Density Estimation(KDE)**    

* Definition

  > *A sum of "bumps" placed at the observations. The kernel function determines the shape of the bumps while the window width, h, determines their width.*

<div style="width:600px; height:380px">    
![](D:\Desktop\2.png)
</div>
* Shape of "bumps"
    + Many overlapping lines -> a higher value -> a higher density.   
    + The plot shows us regions of high and low density -> the empirical probability density function.    
    + **Mode**: Value at which probability density function has its maximum value.    
* About the bandwidth(h)    
    + Generally: Use the default.   
    + Lower bandwidth: More subtle features in your density plot, peaks becomes higher.   
* `geom_density()` cuts of the minimum & maximum values of our dataset,   
<div style="width:600px; height:460px">    
![](D:\Desktop\3.png)
</div>
* `geom_density()`
    + `bw` the smoothing bandwidth to be used.    
    + `adjust` adjustment of the bandwidth.   
    + `kernel` kernel used for density estimation: 'gaussian', 'rectangular', 'triangular', 'epanechnikov', 'biweight', 'cosine', 'optcosine'.
    
```{r message = F}
test_data <- get(load('D:/Downloads/test_datasets.RData'))
# Calculating density: d
d <- density(test_data$norm)

# Use which.max() to calculate mode
mode <- d$x[which.max(d$y)]

# Finish the ggplot call
ggplot(test_data, aes(x = norm)) +
  geom_density() +
  geom_rug() +
  geom_vline(xintercept = mode, col = "red")

# Combine density plots and histogram
# Arguments you'll need later on
fun_args <- list(mean = mean(test_data$norm), sd = sd(test_data$norm))

# Finish the ggplot
ggplot(test_data, aes(x = norm)) +
    # Achieve inner data
    geom_histogram(aes(y = ..density..)) +
    geom_density(col = 'red') +
  # dnorm gives the density
    stat_function(fun = dnorm, args = fun_args, col = 'blue')
```

<br>

<h4 id = '1.3.2'></h4>
#### **Mulitple Density Plots**
```{r, message = F}
library(tidyr)
test_data <- get(load('D:/Downloads/test_datasets.RData'))
test_data2 <- gather(test_data, dist, value, 1:2)
# Plot two distributions with test_data2
ggplot(test_data2, aes(x = value, fill = dist, col = dist)) +
  geom_rug(alpha = 0.4) +
  geom_density(alpha = 0.4)
```

#### **Example: mammals**
```{r}
mammals <- readRDS('D:/Downloads/mammals.RDS')
# With faceting
ggplot(mammals, aes(x = sleep_total, fill = vore)) +
  geom_density(col = NA, alpha = 0.35) +
  scale_x_continuous(limits = c(0, 24)) +
  coord_cartesian(ylim = c(0, 0.3)) +
  facet_wrap( ~ vore, nrow = 2)
# Trim each density plot individually
ggplot(mammals, aes(x = sleep_total, fill = vore)) +
  geom_density(col = NA, alpha = 0.35, trim = T) +
  scale_x_continuous(limits=c(0,24)) +
  coord_cartesian(ylim = c(0, 0.3))
```

* Multiple density plots extend the range of all values to the total extent of the *entire* dataset.    
* Cut off at the extreme ends by setting `trim = TRUE` inside `geom_density()`.   
* However, since cut off at ends the area under the curve technically is not equal to one anymore.    

<br>

<h4 id = '1.3.3'></h4>
#### **Violin Plots**

* Puts a density plot onto a vertical axis.   
* Mirrors it to create a symmetrical two dimensional shape.   

```{r}
# Unweighted violin plot
ggplot(mammals, aes(x = vore, y = sleep_total, fill = vore)) +
  geom_violin(col = NA)
```
<br>

<h4 id = '1.3.4'></h4>
#### **Weighted Density Plots**

* When you compare several variables (e.g.eating habits) it's useful to see the density of each subset in relation to the whole data set.     
* This holds true for multiple density plots as well as for violin plots.

```{r, message = F, warning = F}
# Calculate weighting measure
library(dplyr)
mammals2 <- mammals %>%
  group_by(vore) %>%
  mutate(n = n() / nrow(mammals)) -> mammals

# Weighted density plot
ggplot(mammals2, aes(x = sleep_total, fill = vore)) +
  geom_density(aes(weight = n), col = NA, alpha = 0.35) +
  scale_x_continuous(limits = c(0, 24)) +
  coord_cartesian(ylim = c(0, 0.3))

# Weighted violin plot
ggplot(mammals2, aes(x = vore, y = sleep_total, fill = vore)) +
  geom_violin(aes(weight = n), col = NA)
```

<br>

<h3 id = '1.4'></h3>
## 2D Density Plots

* You can consider two orthogonal density plots in the form of a 2D density plot.    
* Like with a 1D density plot, you can adjust the bandwidth of both axes independently.  
* `stat_density_2D()`
    + Define the bandwidths for the x and y axes by assigning a 2-element long vector to `h`.    
    + `h = c(5, 0.5)`

```{r}
library(datasets)
# Base layers
p <- ggplot(faithful, aes(x = waiting, y = eruptions)) +
  scale_y_continuous(limits = c(1, 5.5), expand = c(0, 0)) +
  scale_x_continuous(limits = c(40, 100), expand = c(0, 0)) +
  coord_fixed(60 / 4.5)

# Use geom_density_2d()
p + geom_density_2d()

# Use stat_density_2d() with arguments
p + stat_density_2d(aes(col = ..level..), h = c(5, 0.5))
```

<br>

<h4 id = '1.4.1'></h4>
#### **2D Density Plots with `viridis`**

* `viridis` package contains multi-hue color palettes suitable for continuous variables.    
* Instead of providing an even color gradient for a continuous scale, they highlight the highest values by using an uneven color gradient on purpose.   
```{r, message = F}
library(viridis)
# Add viridis color scale
p +
  stat_density_2d(geom = "tile", aes(fill = ..density..), h=c(5,.5), contour = FALSE) +
  scale_fill_viridis()
```

<br>

<h2 id = '2'></h2>
# **Plots for Specific Data Types** 
